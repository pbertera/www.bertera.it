<!DOCTYPE html>
<html lang="en">
<head>
  <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,400italic' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" type="text/css" href="https://www.bertera.it/theme/stylesheet/style.min.css">

  <link rel="stylesheet" type="text/css" href="https://www.bertera.it/theme/pygments/default.min.css">
  <link rel="stylesheet" type="text/css" href="https://www.bertera.it/theme/font-awesome/css/font-awesome.min.css">


    <link href="https://www.bertera.it/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Pietro Bertera's Blog Atom">



  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="" />

    <!-- Chrome, Firefox OS and Opera -->
    <meta name="theme-color" content="#ff3333">
    <!-- Windows Phone -->
    <meta name="msapplication-navbutton-color" content="#ff3333">
    <!-- iOS Safari -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<meta name="author" content="Pietro" />
<meta name="description" content="What ? This article explain how to setup traffic mirroring on two pods on Red Hat OpenShift Container Platform. This solution is based on tc and vxlan tunnel, this post refer to OpenShift but the general concepts apply to Kubernetes, with some variations depending on specific networking implementation. The main goal ..." />
<meta name="keywords" content="Systems, Network namespaces, OpenShift, Kubernetes">
<meta property="og:site_name" content="Pietro Bertera's Blog"/>
<meta property="og:title" content="Mirroring pod network traffic to another pod on OpenShift"/>
<meta property="og:description" content="What ? This article explain how to setup traffic mirroring on two pods on Red Hat OpenShift Container Platform. This solution is based on tc and vxlan tunnel, this post refer to OpenShift but the general concepts apply to Kubernetes, with some variations depending on specific networking implementation. The main goal ..."/>
<meta property="og:locale" content="en_US"/>
<meta property="og:url" content="https://www.bertera.it/mirroring-pod-network-traffic-to-another-pod-on-openshift.html"/>
<meta property="og:type" content="article"/>
<meta property="article:published_time" content="2022-02-04 00:00:00+01:00"/>
<meta property="article:modified_time" content=""/>
<meta property="article:author" content="https://www.bertera.it/author/pietro.html">
<meta property="article:section" content="Systems"/>
<meta property="article:tag" content="Systems"/>
<meta property="article:tag" content="Network namespaces"/>
<meta property="article:tag" content="OpenShift"/>
<meta property="article:tag" content="Kubernetes"/>
<meta property="og:image" content="//s.gravatar.com/avatar/f64fc3d41c2a8368feff0b7672ca7571?s=120">
  <title>Pietro Bertera's Blog &ndash; Mirroring pod network traffic to another pod on OpenShift</title>
</head>
<body>
  <aside>
    <div>
      <a href="https://www.bertera.it">
        <img src="//s.gravatar.com/avatar/f64fc3d41c2a8368feff0b7672ca7571?s=120" alt="Pietro Bertera" title="Pietro Bertera">
      </a>
      <h1><a href="https://www.bertera.it">Pietro Bertera</a></h1>
<p>Something about ...</p>      <nav>
        <ul class="list">
          <li><a href="https://www.bertera.it/pages/about.html#about">About</a></li>
          <li><a href="https://www.bertera.it/pages/contact.html#contact">Contact</a></li>
        </ul>
      </nav>
      <ul class="social">
        <li><a class="sc-linkedin" href="https://www.linkedin.com/in/pietrobertera" target="_blank"><i class="fa fa-linkedin"></i></a></li>
        <li><a class="sc-github" href="https://github.com/pbertera" target="_blank"><i class="fa fa-github"></i></a></li>
        <li><a class="sc-twitter" href="https://twitter.com/pbertera" target="_blank"><i class="fa fa-twitter"></i></a></li>
        <li><a class="sc-rss" href="//bertera.it/feeds/all.atom.xml" target="_blank"><i class="fa fa-rss"></i></a></li>
      </ul>
    </div>
  </aside>
  <main>
    <nav>
      <a href="https://www.bertera.it">Home</a>
      <a href="/archives.html">Archives</a>
      <a href="/categories.html">Categories</a>
      <a href="/tags.html">Tags</a>
      <a href="https://www.bertera.it/feeds/all.atom.xml">Atom</a>
    </nav>

<article>
  <header>
    <h1 id="mirroring-pod-network-traffic-to-another-pod-on-openshift">Mirroring pod network traffic to another pod on OpenShift</h1>
    <p>Posted on Fri 04 February 2022 in <a href="https://www.bertera.it/category/systems.html">Systems</a></p>
  </header>
  <div>
    <h2>What ?</h2>
<p>This article explain how to setup traffic mirroring on two pods on Red Hat OpenShift Container Platform.
This solution is based on <code>tc</code> and <code>vxlan</code> tunnel, this post refer to OpenShift but the general concepts apply to Kubernetes, with some variations depending on specific networking implementation.</p>
<p>The main goal is to send all the network packets (from the link layer) in transit on the main network interface of a pod to a different pod.
This approach investigates how to mirror the network traffic on a running pod, without restarting it.
Implementing a persistent solution is out of the scope of this article (maybe a next one? :) ).</p>
<p>For clarity we will use the following names to identify the pods:</p>
<ul>
<li><code>app-pod</code>: the application pod that we want to monitor</li>
<li><code>receiver-pod</code>: the pod receiving the mirrored network trafic from <code>app-pod</code></li>
</ul>
<p><img alt="mirror pod" src="https://www.bertera.it/mirror-pods.png" /></p>
<h2>Why ?</h2>
<p>A network mirror con be useful in many cases: setup a network monitor to debug weird issues, for security resons (Eg. an IDS) or analyse network performance issues.
Usually traffic mirroring solutions are based on hardware network switches, this approach is difficult to integrate on orchestrated container environments where networsk are software-defined.
In this article we will setup a network mirroring fully software without the need of any harware.</p>
<h2>How ?</h2>
<p>In order to deliver the mirrored packets to a different pod we need to encapsulate the frames into a tunnel network between the <code>app-pod</code> and the <code>receiver-pod</code>.
Theoretically would be possible to deliver the mirrored packet to a pod running on a different node or even on a different cluster.
In this example the <code>app-pod</code> and <code>receiver-pod</code> must run on the same node.</p>
<p>In this way the <code>receiver-pod</code> can decapsulate the outer frame to extract the mirrored data.
In our example we will use VxLAN as a tunneling protocol, but many other options are possible (GRE, IP-IP, IPSec, etc..).</p>
<p>First of all we need to start the two pods:</p>
<div class="highlight"><pre><span></span><span class="gp">user@bastion $</span> cat &lt;&lt; EOF <span class="p">|</span> oc create -f -
<span class="go">apiVersion: v1</span>
<span class="go">kind: Pod</span>
<span class="go">metadata:</span>
<span class="go">  name: app-pod</span>
<span class="go">spec:</span>
<span class="gp">  #</span> same node of app-pod
<span class="go">  nodeName: worker-3</span>
<span class="go">  containers:</span>
<span class="go">  - name: main</span>
<span class="go">    image: quay.io/pbertera/net-tools</span>
<span class="gp">    #</span> execute ping to generate dummy network traffic
<span class="go">    command:</span>
<span class="go">    - /bin/bash</span>
<span class="go">    - -c</span>
<span class="go">    - ping 8.8.8.8</span>
<span class="go">---</span>
<span class="go">apiVersion: v1</span>
<span class="go">kind: Pod</span>
<span class="go">metadata:</span>
<span class="go">  name: receiver-pod</span>
<span class="go">spec:</span>
<span class="go">  nodeName: worker-3 </span>
<span class="go">  containers:</span>
<span class="go">  - name: main</span>
<span class="go">    image: quay.io/pbertera/net-tools</span>
<span class="gp">    #</span> Run as root so we can execute tcpdump to verify the mirroring
<span class="go">    securityContext:</span>
<span class="go">      privileged: true</span>
<span class="go">      runAsUser: 0</span>
<span class="go">    command:</span>
<span class="go">    - /bin/bash</span>
<span class="go">    - -c</span>
<span class="go">    - sleep inf</span>
<span class="go">EOF</span>
</pre></div>


<p>The two pods should be running on the same node:</p>
<div class="highlight"><pre><span></span><span class="gp">user@bastion $</span> oc get pods -o wide
<span class="go">NAME           READY   STATUS    RESTARTS   AGE   IP             NODE       NOMINATED NODE   READINESS GATES</span>
<span class="go">app-pod        1/1     Running   0          27s   10.130.2.247   worker-3   &lt;none&gt;           &lt;none&gt;</span>
<span class="go">receiver-pod   1/1     Running   0          27s   10.130.2.246   worker-3   &lt;none&gt;           &lt;none&gt;</span>
</pre></div>


<p>Now on the node where the pods are running we have to identify the network namespaces of each pod</p>
<div class="highlight"><pre><span></span><span class="gp">core@worker-3 $</span> <span class="nv">app_pod_id</span><span class="o">=</span><span class="k">$(</span>sudo crictl pods --name app-pod -q<span class="k">)</span>
<span class="gp">core@worker-3 $</span> <span class="nv">netns_app</span><span class="o">=</span><span class="k">$(</span>sudo crictl inspectp <span class="nv">$app_pod_id</span> <span class="p">|</span> jq -r <span class="s1">&#39;.info.runtimeSpec.linux.namespaces[] | select(.type == &quot;network&quot;) | .path&#39;</span> <span class="p">|</span> cut -d <span class="se">\/</span> -f <span class="m">5</span><span class="k">)</span>

<span class="gp">core@worker-3 $</span> <span class="nv">receiver_pod_id</span><span class="o">=</span><span class="k">$(</span>sudo crictl pods --name receiver-pod -q<span class="k">)</span>
<span class="gp">core@worker-3 $</span> <span class="nv">netns_receiver</span><span class="o">=</span><span class="k">$(</span>sudo crictl inspectp <span class="nv">$receiver_pod_id</span> <span class="p">|</span> jq -r <span class="s1">&#39;.info.runtimeSpec.linux.namespaces[] | select(.type == &quot;network&quot;) | .path&#39;</span> <span class="p">|</span> cut -d <span class="se">\/</span> -f <span class="m">5</span><span class="k">)</span>
</pre></div>


<p>Now we create the <code>mirror0</code> bridge device on the node</p>
<div class="highlight"><pre><span></span><span class="gp">core@worker-3 $</span> sudo ip link add mirror0 <span class="nb">type</span> bridge
<span class="gp">core@worker-3 $</span> sudo ip addr add <span class="m">10</span>.1.99.1/24 dev mirror0
<span class="gp">core@worker-3 $</span> sudo ip link <span class="nb">set</span> up dev mirror0
</pre></div>


<p>At this point we create an additional network device in the <code>app_pod</code>, we will use this device to setup the VxLAN tunnel</p>
<div class="highlight"><pre><span></span><span class="gp">core@worker-3 $</span> sudo ip link add veth1 <span class="nb">type</span> veth peer name peer1
<span class="gp">core@worker-3 $</span> sudo ip link <span class="nb">set</span> peer1 netns <span class="nv">$netns_app</span>
<span class="gp">core@worker-3 $</span> sudo ip netns <span class="nb">exec</span> <span class="nv">$netns_app</span> ip link <span class="nb">set</span> peer1 name eth1 <span class="c1"># rname to eth1</span>
<span class="gp">core@worker-3 $</span> sudo ip netns <span class="nb">exec</span> <span class="nv">$netns_app</span> ip addr add <span class="m">10</span>.1.99.2/24 dev eth1
<span class="gp">core@worker-3 $</span> sudo ip netns <span class="nb">exec</span> <span class="nv">$netns_app</span> ip link <span class="nb">set</span> eth1 up
</pre></div>


<p>Let's check the <code>eth1</code> device into the pod <code>app-pod</code>:</p>
<div class="highlight"><pre><span></span><span class="gp">user@bastion $</span> oc <span class="nb">exec</span> app-pod -- ip addr show dev eth1
<span class="go">268: eth1@if269: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state LOWERLAYERDOWN group default qlen 1000</span>
<span class="go">    link/ether 9a:a4:12:d0:af:45 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span>
<span class="go">    inet 10.1.99.2/23 scope global eth1</span>
<span class="go">       valid_lft forever preferred_lft forever</span>
</pre></div>


<p>Now we can add the <code>veth1</code> network pair to the <code>mirror0</code> bridge</p>
<div class="highlight"><pre><span></span><span class="gp">core@worker-3 $</span> sudo ip link <span class="nb">set</span> veth1 master mirror0
<span class="gp">core@worker-3 $</span> sudo ip link <span class="nb">set</span> veth1 up
</pre></div>


<p>At this point we have the <code>app-pod</code> with an additional network interface (<code>eth1</code>) connected to the <code>mirror0</code> bridge on the host networ knamespace.
Now we have to connect the receiver pod to the bridge:</p>
<div class="highlight"><pre><span></span><span class="gp">core@worker-3 $</span> sudo ip link add veth2 <span class="nb">type</span> veth peer name peer2
<span class="gp">core@worker-3 $</span> sudo ip link <span class="nb">set</span> peer2 netns <span class="nv">$netns_receiver</span>
<span class="gp">core@worker-3 $</span> sudo ip netns <span class="nb">exec</span> <span class="nv">$netns_receiver</span> ip link <span class="nb">set</span> peer2 name eth1
<span class="gp">core@worker-3 $</span> sudo ip netns <span class="nb">exec</span> <span class="nv">$netns_receiver</span> ip addr add <span class="m">10</span>.1.99.3/24 dev eth1
<span class="gp">core@worker-3 $</span> sudo ip netns <span class="nb">exec</span> <span class="nv">$netns_receiver</span> ip link <span class="nb">set</span> eth1 up
<span class="gp">core@worker-3 $</span> sudo ip link <span class="nb">set</span> veth2 master mirror0
<span class="gp">core@worker-3 $</span> sudo ip link <span class="nb">set</span> veth2 up
</pre></div>


<p>Now that both pods are connected to the <code>mirror0</code> bridge we can test the connectivity between the 2 pods through the newly added <code>veth</code> pairs</p>
<div class="highlight"><pre><span></span><span class="gp">user@bastion $</span> oc <span class="nb">exec</span> -it receiver-pod -- ping <span class="m">10</span>.1.99.2 -c3
<span class="go">PING 10.1.99.2 (10.1.99.2) 56(84) bytes of data.</span>
<span class="go">64 bytes from 10.1.99.2: icmp_seq=1 ttl=63 time=1.24 ms</span>
<span class="go">64 bytes from 10.1.99.2: icmp_seq=2 ttl=63 time=0.169 ms</span>
<span class="go">64 bytes from 10.1.99.2: icmp_seq=3 ttl=63 time=0.243 ms</span>
</pre></div>


<p>Now that the two pods are connected through the bridge we can setup the VxLAN tunnel</p>
<div class="highlight"><pre><span></span><span class="gp">core@worker-3 $</span> sudo ip netns <span class="nb">exec</span> <span class="nv">$netns_app</span> ip link add vxlan0 <span class="nb">type</span> vxlan id <span class="m">100</span> <span class="nb">local</span> <span class="m">10</span>.1.99.2 remote <span class="m">10</span>.1.99.3 dev eth1 dstport <span class="m">4789</span>
<span class="gp">core@worker-3 $</span> sudo ip netns <span class="nb">exec</span> <span class="nv">$netns_app</span> ip link <span class="nb">set</span> vxlan0 up
<span class="gp">core@worker-3 $</span> sudo ip netns <span class="nb">exec</span> <span class="nv">$netns_receiver</span> ip link add vxlan0 <span class="nb">type</span> vxlan id <span class="m">100</span> <span class="nb">local</span> <span class="m">10</span>.1.99.3 remote <span class="m">10</span>.1.99.2 dev eth1 dstport <span class="m">4789</span>
<span class="gp">core@worker-3 $</span> sudo ip netns <span class="nb">exec</span> <span class="nv">$netns_receiver</span> ip link <span class="nb">set</span> vxlan0 up
</pre></div>


<p>The following commands will configure <code>tc</code> to mirror all the ingress traffic of <code>eth0</code> of the <code>app-pod</code> to the <code>vxlan0</code> device:</p>
<div class="highlight"><pre><span></span><span class="gp">core@worker-3 $</span> sudo ip netns <span class="nb">exec</span> <span class="nv">$netns_app</span> tc qdisc add dev eth0 handle ffff: ingress
<span class="gp">core@worker-3 $</span> sudo ip netns <span class="nb">exec</span> <span class="nv">$netns_app</span> tc filter add dev eth0 parent ffff: protocol all u32 match u32 <span class="m">0</span> <span class="m">0</span> action mirred egress mirror dev vxlan0
</pre></div>


<p>Here we do the same for the egress traffic on <code>app_pod</code></p>
<div class="highlight"><pre><span></span><span class="gp">core@worker-3 $</span> sudo ip netns <span class="nb">exec</span> <span class="nv">$netns_app</span> tc qdisc add dev eth0 handle <span class="m">1</span>: root prio
<span class="gp">core@worker-3 $</span> sudo ip netns <span class="nb">exec</span> <span class="nv">$netns_app</span> tc filter add dev eth0 parent <span class="m">1</span>: protocol all u32 match u8 <span class="m">0</span> <span class="m">0</span> action mirred egress mirror dev vxlan0
</pre></div>


<p>Here the mirroring should be completed and we can verify running tcpdump on the receiver pod:</p>
<div class="highlight"><pre><span></span><span class="gp">user@bastion $</span> oc <span class="nb">exec</span> -it receiver-pod -- tcpdump -nn -i vxlan0 -e
<span class="go">dropped privs to tcpdump</span>
<span class="go">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span>
<span class="go">listening on vxlan0, link-type EN10MB (Ethernet), capture size 262144 bytes</span>
<span class="go">20:52:42.791473 0a:58:0a:82:02:f7 &gt; 96:44:79:fb:bc:a1, ethertype IPv4 (0x0800), length 98: 10.130.2.247 &gt; 8.8.8.8: ICMP echo request, id 6, seq 2256, length 64</span>
<span class="go">20:52:42.805062 96:44:79:fb:bc:a1 &gt; 0a:58:0a:82:02:f7, ethertype IPv4 (0x0800), length 98: 8.8.8.8 &gt; 10.130.2.247: ICMP echo reply, id 6, seq 2256, length 64</span>
<span class="go">20:52:43.791666 0a:58:0a:82:02:f7 &gt; 96:44:79:fb:bc:a1, ethertype IPv4 (0x0800), length 98: 10.130.2.247 &gt; 8.8.8.8: ICMP echo request, id 6, seq 2257, length 64</span>
</pre></div>


<p>As you can see the <code>receiver-pod</code> is getting the ICMP requests and reply the <code>app-pod</code> on transit on <code>eth0</code> of <code>app-pod</code>.</p>
  </div>
  <div class="tag-cloud">
    <p>
      <a href="https://www.bertera.it/tag/systems.html">Systems</a>
      <a href="https://www.bertera.it/tag/network-namespaces.html">Network namespaces</a>
      <a href="https://www.bertera.it/tag/openshift.html">OpenShift</a>
      <a href="https://www.bertera.it/tag/kubernetes.html">Kubernetes</a>
    </p>
  </div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'bertera-it';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</article>

    <footer>
<p>
  &copy; Pietro Bertera 2016 - This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>
</p>
<p>Built using <a href="http://getpelican.com" target="_blank">Pelican</a> - <a href="https://github.com/alexandrevicenzi/flex" target="_blank">Flex</a> theme by <a href="http://alexandrevicenzi.com" target="_blank">Alexandre Vicenzi</a></p><p>
  <a rel="license"
     href="http://creativecommons.org/licenses/by-sa/4.0/"
     target="_blank">
    <img alt="Creative Commons License"
         title="Creative Commons License"
         style="border-width:0"
         src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png"
         width="80"
         height="15"/>
  </a>
</p>    </footer>
  </main>





<script type="application/ld+json">
{
  "@context" : "http://schema.org",
  "@type" : "Blog",
  "name": " Pietro Bertera's Blog ",
  "url" : "https://www.bertera.it",
  "image": "//s.gravatar.com/avatar/f64fc3d41c2a8368feff0b7672ca7571?s=120",
  "description": "Pietro Bertera's Thoughts and Writings"
}
</script>
<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "name": "Mirroring pod network traffic to another pod on OpenShift",
  "headline": "Mirroring pod network traffic to another pod on OpenShift",
  "datePublished": "2022-02-04 00:00:00+01:00",
  "dateModified": "",
  "author": {
    "@type": "Person",
    "name": "Pietro",
    "url": "https://www.bertera.it/author/pietro.html"
  },
  "image": "//s.gravatar.com/avatar/f64fc3d41c2a8368feff0b7672ca7571?s=120",
  "url": "https://www.bertera.it/mirroring-pod-network-traffic-to-another-pod-on-openshift.html",
  "description": "What ? This article explain how to setup traffic mirroring on two pods on Red Hat OpenShift Container Platform. This solution is based on tc and vxlan tunnel, this post refer to OpenShift but the general concepts apply to Kubernetes, with some variations depending on specific networking implementation. The main goal ..."
}
</script></body>
</html>